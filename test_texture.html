<!DOCTYPE html>
<html>
<head>
	<title>test texture</title>
	<meta charset="utf-8">
	<script src="./libs/three.js"></script>
	<script src="./libs/orbitControls.js"></script>
	<script src="./libs/stats.min.js"></script>

	<style type="text/css">
		* {
			margin: 0;
			padding: 0;
		}

		body {
			width: 100%;
			height: 100%;
			overflow: hidden;
		}
	</style>

</head>



<body>

	<script type="text/javascript">

		window.addEventListener('load', function() {
			main();
			loop();
		})
		
		var scene, renderer, camera, controls, clock, stats;
		const WIDTH = window.innerWidth;
		const HEIGHT = window.innerHeight;

		var boomer;


		function main() {

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xd0ffc1);

			camera = new THREE.PerspectiveCamera(30, WIDTH/HEIGHT, 0.1, 1000);
			camera.position.set(0, 0, 30);

			controls = new THREE.OrbitControls(camera, document.body);

			renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
			renderer.setSize(WIDTH, HEIGHT);
			document.body.appendChild(renderer.domElement);

			clock = new THREE.Clock();

			stats = new Stats();
			document.body.appendChild(stats.dom);

			////////////////////
			///	CUSTOM CODE
			////////////////////

			
			var spriteMap = new THREE.TextureLoader().load("textures/explosion.png");
			boomer = new TextureAnimator( spriteMap, 4, 4, 16, 55 );
			var spriteMaterial = new THREE.SpriteMaterial({map:spriteMap, color:0xffffff});
			var sprite = new THREE.Sprite(spriteMaterial);
			scene.add(sprite);


			////////////////////
			///	SPHERES
			////////////////////

			for (let i=0 ; i<20 ; i++) {
				let sphere = createSphere();
				sphere.position.set(
					(Math.random()-0.5)*30,
					(Math.random()-0.5)*30,
					(Math.random()-0.5)*30
					)
				scene.add(sphere);
			}

			function createSphere() {
				return new THREE.Mesh(new THREE.SphereBufferGeometry(1, 16, 16),
											new THREE.MeshNormalMaterial() );
			};

		};



		function loop() {
			requestAnimationFrame(loop);
			renderer.render(scene, camera);
			stats.update();

			var delta = clock.getDelta();
			boomer.update(1000 * delta);
		};


		// This function offset a texture containing several frames of an animation, to animate it.
		function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) {
			// texture: Three.js texture object.
			// tilesHoriz: number of frames on the X axis of the texture.
			// tilesVert: number of frames on the Y axis of the texture.
			// numTiles: total number of frames, in case it's not equal to tilesHoriz*tilesVert 
			//  and the last tiles are empty.
			// tileDispDuration: duration of display of each frame (or 'tile').

			this.tilesHorizontal = tilesHoriz ;
			this.tilesVertical = tilesVert ;
			this.numberOfTiles = numTiles ;
			this.tileDisplayDuration = tileDispDuration;
			this.currentDisplayTime = 0;
			this.currentTile = 0;

			// This defines of the texture is wrapped on the object it's applied on.
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			// texture.repeat tells how much times the texture is repeated 
			// accross the surface. In our case it's a fraction, so it's reduced.
			texture.repeat.set( 1/this.tilesHorizontal, 1/this.tilesVertical );

			// This compute the offset of the texture like this:
			// this_column / total_colomn --> 3/4 = 0.75 --> the offset is 0.75 (total is 1).
			this.offsetTexture = function offsetTexture() {
				var currentColumn = this.currentTile % this.tilesHorizontal;
				texture.offset.x = currentColumn / this.tilesHorizontal;
				var currentRow = Math.floor(this.currentTile / this.tilesHorizontal);
				texture.offset.y = (this.tilesVertical - currentRow - 1) / this.tilesVertical;
			};

			// call it at instantiation, or the animation does not start at first frame.
			this.offsetTexture();

			this.update = function update(milliSec) {
				
				// udpate() is called with the number of milliseconds to play in the anim.
				this.currentDisplayTime += milliSec;

				while (this.currentDisplayTime > this.tileDisplayDuration) {
					// This while loop while be called several time is the passed milliSec
					// parameter is longer than a frame last.
					this.currentDisplayTime -= this.tileDisplayDuration;
					this.currentTile ++;

					if (this.currentTile == this.numberOfTiles) {
						this.currentTile = 0;
					}; // Restarts animation if the last frame was reached.

					this.offsetTexture();
				};

			};

		};



	</script>

</body>
</html>